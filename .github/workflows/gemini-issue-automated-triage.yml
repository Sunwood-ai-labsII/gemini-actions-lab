name: 'ðŸ·ï¸ Gemini Automated Issue Triage'

on:
  issues:
    types:
      - 'opened'
      - 'reopened'
  workflow_dispatch:
    inputs:
      issue_number:
        description: 'issue number to triage'
        required: true
        type: 'number'

concurrency:
  group: '${{ github.workflow }}-${{ github.event.issue.number || github.event.inputs.issue_number }}'
  cancel-in-progress: true

defaults:
  run:
    shell: 'bash'

permissions:
  contents: 'read'
  id-token: 'write'
  issues: 'write'
  statuses: 'write'

jobs:
  triage-issue:
    if: |-
      github.event_name == 'issues' ||
      github.event_name == 'workflow_dispatch' ||
      (
        github.event_name == 'issue_comment' &&
        contains(github.event.comment.body, '@gemini-cli /triage') &&
        contains(fromJSON('["OWNER", "MEMBER", "COLLABORATOR"]'), github.event.comment.author_association)
      )
    timeout-minutes: 5
    runs-on: 'ubuntu-latest'
    steps:
      - name: 'Checkout repository'
        uses: 'actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683' # ratchet:actions/checkout@v4

      - name: 'Generate GitHub App Token'
        id: 'generate_token'
        if: |-
          ${{ vars.APP_ID }}
        uses: 'actions/create-github-app-token@df432ceedc7162793a195dd1713ff69aefc7379e' # ratchet:actions/create-github-app-token@v2
        with:
          app-id: '${{ vars.APP_ID }}'
          private-key: '${{ secrets.APP_PRIVATE_KEY }}'

      - name: 'Get Issue Information'
        id: 'get_issue'
        uses: 'actions/github-script@60a0d83039c74a4aee543508d2ffcb1c3799cdea'
        with:
          github-token: '${{ steps.generate_token.outputs.token || secrets.GITHUB_TOKEN }}'
          script: |
            let issueNumber, issueTitle, issueBody;
            
            if (context.eventName === 'workflow_dispatch') {
              // æ‰‹å‹•å®Ÿè¡Œã®å ´åˆã¯inputã‹ã‚‰å–å¾—
              issueNumber = parseInt('${{ github.event.inputs.issue_number }}');
              console.log(`Manual dispatch for issue #${issueNumber}`);
              
              // APIã§issueæƒ…å ±ã‚’å–å¾—
              const { data: issue } = await github.rest.issues.get({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: issueNumber
              });
              
              issueTitle = issue.title;
              issueBody = issue.body || '';
            } else {
              // é€šå¸¸ã®ã‚¤ãƒ™ãƒ³ãƒˆã®å ´åˆ
              issueNumber = context.payload.issue.number;
              issueTitle = context.payload.issue.title;
              issueBody = context.payload.issue.body || '';
            }
            
            console.log(`Event name: ${context.eventName}`);
            console.log(`Issue number: ${issueNumber}`);
            console.log(`Issue title: '${issueTitle}'`);
            console.log(`Issue body length: ${issueBody.length}`);
            console.log(`Issue body preview: '${issueBody.substring(0, 200)}${issueBody.length > 200 ? '...' : ''}'`);
            
            // å¾Œç¶šã®ã‚¹ãƒ†ãƒƒãƒ—ã§ä½¿ç”¨ã™ã‚‹ãŸã‚ã«å‡ºåŠ›
            core.setOutput('issue_number', issueNumber);
            core.setOutput('issue_title', issueTitle);
            core.setOutput('issue_body', issueBody);

      - name: 'Get Repository Labels'
        id: 'get_labels'
        uses: 'actions/github-script@60a0d83039c74a4aee543508d2ffcb1c3799cdea'
        with:
          github-token: '${{ steps.generate_token.outputs.token || secrets.GITHUB_TOKEN }}'
          script: |-
            const labels = await github.paginate(github.rest.issues.listLabelsForRepo, {
              owner: context.repo.owner,
              repo: context.repo.repo,
              per_page: 100,
            });
            const labelNames = labels.map(label => label.name).filter(Boolean);
            core.setOutput('available_labels', labelNames.join(','));
            core.info(`Found ${labelNames.length} labels: ${labelNames.join(', ')}`);
            return labelNames;

      - name: 'Run Gemini Issue Analysis'
        uses: 'google-github-actions/run-gemini-cli@v0'
        id: 'gemini_issue_analysis'
        env:
          GITHUB_TOKEN: '' # Do not pass any auth token here since this runs on untrusted inputs
          ISSUE_TITLE: '${{ steps.get_issue.outputs.issue_title }}'
          ISSUE_BODY: '${{ steps.get_issue.outputs.issue_body }}'
          ISSUE_NUMBER: '${{ steps.get_issue.outputs.issue_number }}'
          REPOSITORY: '${{ github.repository }}'
          AVAILABLE_LABELS: '${{ steps.get_labels.outputs.available_labels }}'
        with:
          gemini_cli_version: '${{ vars.GEMINI_CLI_VERSION }}'
          gcp_workload_identity_provider: '${{ vars.GCP_WIF_PROVIDER }}'
          gcp_project_id: '${{ vars.GOOGLE_CLOUD_PROJECT }}'
          gcp_location: '${{ vars.GOOGLE_CLOUD_LOCATION }}'
          gcp_service_account: '${{ vars.SERVICE_ACCOUNT_EMAIL }}'
          gemini_api_key: '${{ secrets.GEMINI_API_KEY }}'
          use_vertex_ai: '${{ vars.GOOGLE_GENAI_USE_VERTEXAI }}'
          use_gemini_code_assist: '${{ vars.GOOGLE_GENAI_USE_GCA }}'
          settings: |-
            {
              "debug": true,
              "maxSessionTurns": 25,
              "coreTools": [],
              "telemetry": {
                "enabled": false,
                "target": "gcp"
              }
            }
          prompt: |-
            You are an expert GitHub issue triage assistant. Your task is to analyze the provided issue and suggest appropriate labels.

            **ISSUE DETAILS:**
            Repository: ${REPOSITORY}
            Issue Number: ${ISSUE_NUMBER}
            Title: "${ISSUE_TITLE}"
            Body: "${ISSUE_BODY}"

            **AVAILABLE LABELS:**
            ${AVAILABLE_LABELS}

            **INSTRUCTIONS:**
            1. Carefully analyze the issue title and body content
            2. Select appropriate labels from the available labels list
            3. If no existing labels are suitable, suggest new labels that would be helpful
            4. Provide a brief explanation for your label choices

            **CRITICAL: You must respond with ONLY a valid JSON object in this exact format:**
            
            {
              "labels_to_set": ["label1", "label2"],
              "explanation": "Brief explanation of why these labels were chosen"
            }

            **RULES:**
            - Response must be valid JSON only
            - No additional text before or after the JSON
            - No markdown code blocks
            - No explanatory text outside the JSON
            - If unsure, choose the most general applicable labels
            - If no labels apply, use empty array: []

            **EXAMPLES:**
            Bug report: {"labels_to_set": ["bug"], "explanation": "Issue reports unexpected behavior"}
            Feature request: {"labels_to_set": ["enhancement"], "explanation": "User requesting new functionality"}
            Documentation: {"labels_to_set": ["documentation"], "explanation": "Related to documentation updates"}

            Analyze the issue now and respond with the JSON:

      - name: 'Apply Labels to Issue'
        if: |-
          ${{ steps.gemini_issue_analysis.outputs.summary != '' }}
        env:
          REPOSITORY: '${{ github.repository }}'
          ISSUE_NUMBER: '${{ steps.get_issue.outputs.issue_number }}'
          LABELS_OUTPUT: '${{ steps.gemini_issue_analysis.outputs.summary }}'
        uses: 'actions/github-script@60a0d83039c74a4aee543508d2ffcb1c3799cdea'
        with:
          github-token: '${{ secrets.GH_PAT || steps.generate_token.outputs.token || secrets.GITHUB_TOKEN }}'
          script: |-
            // Strip code block markers if present and extract JSON
            const rawLabels = process.env.LABELS_OUTPUT;
            core.info(`Raw labels output: ${rawLabels}`);
            
            let parsedLabels;
            try {
              // æ”¹è‰¯ã•ã‚ŒãŸJSONæŠ½å‡ºãŠã‚ˆã³æ¤œè¨¼ãƒ­ã‚¸ãƒƒã‚¯
              let jsonString = rawLabels.trim();
              
              // ã¾ãšã€ç”Ÿã®å‡ºåŠ›ãŒJSONã‹ã©ã†ã‹ã‚’ãƒã‚§ãƒƒã‚¯
              if (!jsonString.startsWith('{') && !jsonString.startsWith('[')) {
                // JSONã§ã¯ãªã„å ´åˆã€ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯å‡¦ç†
                core.warning(`Output is not JSON format: ${jsonString}`);
                
                // åŸºæœ¬çš„ãªãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯: ç©ºã®ãƒ©ãƒ™ãƒ«é…åˆ—ã‚’è¿”ã™
                parsedLabels = {
                  labels_to_set: [],
                  explanation: `Failed to parse Gemini output: ${jsonString.substring(0, 100)}...`
                };
              } else {
                // 1. ```json ``` ãƒ–ãƒ­ãƒƒã‚¯ã‚’æŠ½å‡º
                const jsonBlockMatch = jsonString.match(/```json\s*([\s\S]*?)\s*```/);
                if (jsonBlockMatch) {
                  jsonString = jsonBlockMatch[1].trim();
                  core.info(`Extracted JSON from json code block: ${jsonString}`);
                } else {
                  // 2. ``` ``` ãƒ–ãƒ­ãƒƒã‚¯ã‚’æŠ½å‡ºï¼ˆjsonæŒ‡å®šãªã—ï¼‰
                  const codeBlockMatch = jsonString.match(/```\s*([\s\S]*?)\s*```/);
                  if (codeBlockMatch) {
                    jsonString = codeBlockMatch[1].trim();
                    core.info(`Extracted JSON from code block: ${jsonString}`);
                  } else {
                    // 3. { ã§å§‹ã¾ã£ã¦ } ã§çµ‚ã‚ã‚‹éƒ¨åˆ†ã‚’æŠ½å‡º
                    const jsonObjectMatch = jsonString.match(/(\{[\s\S]*\})/);
                    if (jsonObjectMatch) {
                      jsonString = jsonObjectMatch[1].trim();
                      core.info(`Extracted JSON object: ${jsonString}`);
                    } else {
                      // 4. [ ã§å§‹ã¾ã£ã¦ ] ã§çµ‚ã‚ã‚‹éƒ¨åˆ†ã‚’æŠ½å‡ºï¼ˆé…åˆ—ã®å ´åˆï¼‰
                      const jsonArrayMatch = jsonString.match(/(\[[\s\S]*\])/);
                      if (jsonArrayMatch) {
                        // é…åˆ—ãŒè¿”ã•ã‚ŒãŸå ´åˆã¯ã€æœ€åˆã®è¦ç´ ã‚’ä½¿ç”¨ï¼ˆå˜ä¸€issueç”¨ï¼‰
                        const arrayData = JSON.parse(jsonArrayMatch[1].trim());
                        if (Array.isArray(arrayData) && arrayData.length > 0) {
                          // ç¾åœ¨ã®issueç•ªå·ã«ä¸€è‡´ã™ã‚‹ã‚‚ã®ã‚’æŽ¢ã™
                          const currentIssueNumber = parseInt(process.env.ISSUE_NUMBER);
                          const matchingIssue = arrayData.find(item => item.issue_number === currentIssueNumber);
                          if (matchingIssue) {
                            parsedLabels = {
                              labels_to_set: matchingIssue.labels_to_set,
                              explanation: matchingIssue.explanation
                            };
                          } else {
                            // ä¸€è‡´ã™ã‚‹issueç•ªå·ãŒãªã„å ´åˆã¯æœ€åˆã®è¦ç´ ã‚’ä½¿ç”¨
                            const firstItem = arrayData[0];
                            parsedLabels = {
                              labels_to_set: firstItem.labels_to_set,
                              explanation: firstItem.explanation
                            };
                          }
                          core.info(`Successfully parsed from array: ${JSON.stringify(parsedLabels)}`);
                        }
                      }
                    }
                  }
                }
                
                // ã¾ã parsedLabelsãŒè¨­å®šã•ã‚Œã¦ã„ãªã„å ´åˆã€é€šå¸¸ã®JSONãƒ‘ãƒ¼ã‚¹ã‚’è©¦è¡Œ
                if (!parsedLabels) {
                  parsedLabels = JSON.parse(jsonString);
                  core.info(`Successfully parsed labels JSON: ${JSON.stringify(parsedLabels)}`);
                }
                
                // çµæžœã®æ¤œè¨¼
                if (!parsedLabels.labels_to_set) {
                  parsedLabels.labels_to_set = [];
                }
                if (!Array.isArray(parsedLabels.labels_to_set)) {
                  parsedLabels.labels_to_set = [];
                }
                if (!parsedLabels.explanation) {
                  parsedLabels.explanation = "No explanation provided";
                }
              }
            } catch (err) {
              core.warning(`Failed to parse labels JSON from Gemini output: ${err.message}`);
              core.info(`Raw output: ${rawLabels}`);
              
              // ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯: ç©ºã®ãƒ©ãƒ™ãƒ«é…åˆ—ã‚’ä½¿ç”¨
              parsedLabels = {
                labels_to_set: [],
                explanation: `Parsing failed: ${err.message}`
              };
            }

            const issueNumber = parseInt(process.env.ISSUE_NUMBER);

            // Track available labels and allow auto-create of missing labels using GH_PAT
            const available = new Set(
              (process.env.AVAILABLE_LABELS || '')
                .split(',')
                .map(s => s.trim())
                .filter(Boolean)
            );

            // Set labels based on triage result
            if (parsedLabels.labels_to_set && parsedLabels.labels_to_set.length > 0) {
              const proposed = [...new Set(parsedLabels.labels_to_set.map(s => String(s).trim()).filter(Boolean))];

              // Attempt to create any missing labels using the provided token
              for (const label of proposed) {
                if (available.has(label)) continue;
                try {
                  await github.rest.issues.createLabel({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    name: label,
                    color: 'ededed',
                    description: 'Auto-created by Gemini triage'
                  });
                  core.info(`Created missing label: ${label}`);
                  available.add(label);
                } catch (err) {
                  // Ignore if already exists (422), otherwise log error and continue
                  const status = err?.status || err?.response?.status;
                  if (status === 422) {
                    core.info(`Label already exists (race): ${label}`);
                    available.add(label);
                  } else {
                    core.error(`Failed to create label '${label}': ${err}`);
                  }
                }
              }

              const finalLabels = proposed.filter(l => available.has(l));
              if (finalLabels.length === 0) {
                const explanation = parsedLabels.explanation ? ` - ${parsedLabels.explanation}` : '';
                core.info(`No applicable labels for #${issueNumber} after creation attempts. Skipping.${explanation}`);
              } else {
                await github.rest.issues.addLabels({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: issueNumber,
                  labels: finalLabels
                });
                const explanation = parsedLabels.explanation ? ` - ${parsedLabels.explanation}` : '';
                core.info(`Applied labels for #${issueNumber}: ${finalLabels.join(', ')}${explanation}`);
              }
            } else {
              // If no labels to set, leave the issue as is
              const explanation = parsedLabels.explanation ? ` - ${parsedLabels.explanation}` : '';
              core.info(`No labels to set for #${issueNumber}, leaving as is${explanation}`);
            }

      - name: 'Post Issue Analysis Failure Comment'
        if: |-
          ${{ failure() && steps.gemini_issue_analysis.outcome == 'failure' }}
        env:
          ISSUE_NUMBER: '${{ steps.get_issue.outputs.issue_number }}'
          RUN_URL: '${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}'
        uses: 'actions/github-script@60a0d83039c74a4aee543508d2ffcb1c3799cdea'
        with:
          github-token: '${{ steps.generate_token.outputs.token || secrets.GITHUB_TOKEN }}'
          script: |-
            github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: parseInt(process.env.ISSUE_NUMBER),
              body: `There is a problem with the Gemini CLI issue triaging. Please check the [action logs](${process.env.RUN_URL}) for details.`
            })
