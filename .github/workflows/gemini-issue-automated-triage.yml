name: '🏷️ Gemini Automated Issue Triage'

on:
  issues:
    types:
      - 'opened'
      - 'reopened'
  workflow_dispatch:
    inputs:
      issue_number:
        description: 'issue number to triage'
        required: true
        type: 'number'

concurrency:
  group: '${{ github.workflow }}-${{ github.event.issue.number || github.event.inputs.issue_number }}'
  cancel-in-progress: true

defaults:
  run:
    shell: 'bash'

permissions:
  contents: 'read'
  id-token: 'write'
  issues: 'write'
  statuses: 'write'

jobs:
  triage-issue:
    if: |-
      github.event_name == 'issues' ||
      github.event_name == 'workflow_dispatch' ||
      (
        github.event_name == 'issue_comment' &&
        contains(github.event.comment.body, '@gemini-cli /triage') &&
        contains(fromJSON('["OWNER", "MEMBER", "COLLABORATOR"]'), github.event.comment.author_association)
      )
    timeout-minutes: 5
    runs-on: 'ubuntu-latest'
    steps:
      - name: 'Checkout repository'
        uses: 'actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683' # ratchet:actions/checkout@v4

      - name: 'Generate GitHub App Token'
        id: 'generate_token'
        if: |-
          ${{ vars.APP_ID }}
        uses: 'actions/create-github-app-token@df432ceedc7162793a195dd1713ff69aefc7379e' # ratchet:actions/create-github-app-token@v2
        with:
          app-id: '${{ vars.APP_ID }}'
          private-key: '${{ secrets.APP_PRIVATE_KEY }}'

      - name: 'Get Issue Information'
        id: 'get_issue'
        uses: 'actions/github-script@60a0d83039c74a4aee543508d2ffcb1c3799cdea'
        with:
          github-token: '${{ steps.generate_token.outputs.token || secrets.GITHUB_TOKEN }}'
          script: |
            let issueNumber, issueTitle, issueBody;
            
            if (context.eventName === 'workflow_dispatch') {
              // 手動実行の場合はinputから取得
              issueNumber = parseInt('${{ github.event.inputs.issue_number }}');
              console.log(`Manual dispatch for issue #${issueNumber}`);
              
              // APIでissue情報を取得
              const { data: issue } = await github.rest.issues.get({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: issueNumber
              });
              
              issueTitle = issue.title;
              issueBody = issue.body || '';
            } else {
              // 通常のイベントの場合
              issueNumber = context.payload.issue.number;
              issueTitle = context.payload.issue.title;
              issueBody = context.payload.issue.body || '';
            }
            
            console.log(`Event name: ${context.eventName}`);
            console.log(`Issue number: ${issueNumber}`);
            console.log(`Issue title: '${issueTitle}'`);
            console.log(`Issue body length: ${issueBody.length}`);
            console.log(`Issue body preview: '${issueBody.substring(0, 200)}${issueBody.length > 200 ? '...' : ''}'`);
            
            // 後続のステップで使用するために出力
            core.setOutput('issue_number', issueNumber);
            core.setOutput('issue_title', issueTitle);
            core.setOutput('issue_body', issueBody);

      - name: 'Get Repository Labels'
        id: 'get_labels'
        uses: 'actions/github-script@60a0d83039c74a4aee543508d2ffcb1c3799cdea'
        with:
          github-token: '${{ steps.generate_token.outputs.token || secrets.GITHUB_TOKEN }}'
          script: |-
            const labels = await github.paginate(github.rest.issues.listLabelsForRepo, {
              owner: context.repo.owner,
              repo: context.repo.repo,
              per_page: 100,
            });
            const labelNames = labels.map(label => label.name).filter(Boolean);
            core.setOutput('available_labels', labelNames.join(','));
            core.info(`Found ${labelNames.length} labels: ${labelNames.join(', ')}`);
            return labelNames;

      - name: 'Run Gemini Issue Analysis'
        uses: 'google-github-actions/run-gemini-cli@v0'
        id: 'gemini_issue_analysis'
        env:
          GITHUB_TOKEN: '' # Do not pass any auth token here since this runs on untrusted inputs
          ISSUE_TITLE: '${{ steps.get_issue.outputs.issue_title }}'
          ISSUE_BODY: '${{ steps.get_issue.outputs.issue_body }}'
          ISSUE_NUMBER: '${{ steps.get_issue.outputs.issue_number }}'
          REPOSITORY: '${{ github.repository }}'
          AVAILABLE_LABELS: '${{ steps.get_labels.outputs.available_labels }}'
        with:
          gemini_cli_version: '${{ vars.GEMINI_CLI_VERSION }}'
          gcp_workload_identity_provider: '${{ vars.GCP_WIF_PROVIDER }}'
          gcp_project_id: '${{ vars.GOOGLE_CLOUD_PROJECT }}'
          gcp_location: '${{ vars.GOOGLE_CLOUD_LOCATION }}'
          gcp_service_account: '${{ vars.SERVICE_ACCOUNT_EMAIL }}'
          gemini_api_key: '${{ secrets.GEMINI_API_KEY }}'
          use_vertex_ai: '${{ vars.GOOGLE_GENAI_USE_VERTEXAI }}'
          use_gemini_code_assist: '${{ vars.GOOGLE_GENAI_USE_GCA }}'
          settings: |-
            {
              "debug": true,
              "maxSessionTurns": 25,
              "coreTools": [],
              "telemetry": {
                "enabled": false,
                "target": "gcp"
              }
            }
          prompt: |-
            You are an expert GitHub issue triage assistant. Your task is to analyze the provided issue and suggest appropriate labels.

            **ISSUE DETAILS:**
            Repository: ${REPOSITORY}
            Issue Number: ${ISSUE_NUMBER}
            Title: "${ISSUE_TITLE}"
            Body: "${ISSUE_BODY}"

            **AVAILABLE LABELS:**
            ${AVAILABLE_LABELS}

            **INSTRUCTIONS:**
            1. Carefully analyze the issue title and body content
            2. Select appropriate labels from the available labels list
            3. If no existing labels are suitable, suggest new labels that would be helpful
            4. Provide a brief explanation for your label choices

            **CRITICAL: You must respond with ONLY a valid JSON object in this exact format:**
            
            {
              "labels_to_set": ["label1", "label2"],
              "explanation": "Brief explanation of why these labels were chosen"
            }

            **RULES:**
            - Response must be valid JSON only
            - No additional text before or after the JSON
            - No markdown code blocks
            - No explanatory text outside the JSON
            - If unsure, choose the most general applicable labels
            - If no labels apply, use empty array: []

            **EXAMPLES:**
            Bug report: {"labels_to_set": ["bug"], "explanation": "Issue reports unexpected behavior"}
            Feature request: {"labels_to_set": ["enhancement"], "explanation": "User requesting new functionality"}
            Documentation: {"labels_to_set": ["documentation"], "explanation": "Related to documentation updates"}

            Analyze the issue now and respond with the JSON:

      - name: 'Apply Labels to Issue'
        if: |-
          ${{ steps.gemini_issue_analysis.outputs.summary != '' }}
        env:
          REPOSITORY: '${{ github.repository }}'
          ISSUE_NUMBER: '${{ steps.get_issue.outputs.issue_number }}'
          LABELS_OUTPUT: '${{ steps.gemini_issue_analysis.outputs.summary }}'
        uses: 'actions/github-script@60a0d83039c74a4aee543508d2ffcb1c3799cdea'
        with:
          github-token: '${{ secrets.GH_PAT || steps.generate_token.outputs.token || secrets.GITHUB_TOKEN }}'
          script: |-
            // Strip code block markers if present and extract JSON
            const rawLabels = process.env.LABELS_OUTPUT;
            core.info(`Raw labels output: ${rawLabels}`);
            
            let parsedLabels;
            try {
              // 改良されたJSON抽出および検証ロジック
              let jsonString = rawLabels.trim();
              
              // まず、生の出力がJSONかどうかをチェック
              if (!jsonString.startsWith('{') && !jsonString.startsWith('[')) {
                // JSONではない場合、フォールバック処理
                core.warning(`Output is not JSON format: ${jsonString}`);
                
                // 基本的なフォールバック: 空のラベル配列を返す
                parsedLabels = {
                  labels_to_set: [],
                  explanation: `Failed to parse Gemini output: ${jsonString.substring(0, 100)}...`
                };
              } else {
                // 1. ```json ``` ブロックを抽出
                const jsonBlockMatch = jsonString.match(/```json\s*([\s\S]*?)\s*```/);
                if (jsonBlockMatch) {
                  jsonString = jsonBlockMatch[1].trim();
                  core.info(`Extracted JSON from json code block: ${jsonString}`);
                } else {
                  // 2. ``` ``` ブロックを抽出（json指定なし）
                  const codeBlockMatch = jsonString.match(/```\s*([\s\S]*?)\s*```/);
                  if (codeBlockMatch) {
                    jsonString = codeBlockMatch[1].trim();
                    core.info(`Extracted JSON from code block: ${jsonString}`);
                  } else {
                    // 3. { で始まって } で終わる部分を抽出
                    const jsonObjectMatch = jsonString.match(/(\{[\s\S]*\})/);
                    if (jsonObjectMatch) {
                      jsonString = jsonObjectMatch[1].trim();
                      core.info(`Extracted JSON object: ${jsonString}`);
                    } else {
                      // 4. [ で始まって ] で終わる部分を抽出（配列の場合）
                      const jsonArrayMatch = jsonString.match(/(\[[\s\S]*\])/);
                      if (jsonArrayMatch) {
                        // 配列が返された場合は、最初の要素を使用（単一issue用）
                        const arrayData = JSON.parse(jsonArrayMatch[1].trim());
                        if (Array.isArray(arrayData) && arrayData.length > 0) {
                          // 現在のissue番号に一致するものを探す
                          const currentIssueNumber = parseInt(process.env.ISSUE_NUMBER);
                          const matchingIssue = arrayData.find(item => item.issue_number === currentIssueNumber);
                          if (matchingIssue) {
                            parsedLabels = {
                              labels_to_set: matchingIssue.labels_to_set,
                              explanation: matchingIssue.explanation
                            };
                          } else {
                            // 一致するissue番号がない場合は最初の要素を使用
                            const firstItem = arrayData[0];
                            parsedLabels = {
                              labels_to_set: firstItem.labels_to_set,
                              explanation: firstItem.explanation
                            };
                          }
                          core.info(`Successfully parsed from array: ${JSON.stringify(parsedLabels)}`);
                        }
                      }
                    }
                  }
                }
                
                // まだparsedLabelsが設定されていない場合、通常のJSONパースを試行
                if (!parsedLabels) {
                  parsedLabels = JSON.parse(jsonString);
                  core.info(`Successfully parsed labels JSON: ${JSON.stringify(parsedLabels)}`);
                }
                
                // 結果の検証
                if (!parsedLabels.labels_to_set) {
                  parsedLabels.labels_to_set = [];
                }
                if (!Array.isArray(parsedLabels.labels_to_set)) {
                  parsedLabels.labels_to_set = [];
                }
                if (!parsedLabels.explanation) {
                  parsedLabels.explanation = "No explanation provided";
                }
              }
            } catch (err) {
              core.warning(`Failed to parse labels JSON from Gemini output: ${err.message}`);
              core.info(`Raw output: ${rawLabels}`);
              
              // フォールバック: 空のラベル配列を使用
              parsedLabels = {
                labels_to_set: [],
                explanation: `Parsing failed: ${err.message}`
              };
            }

            const issueNumber = parseInt(process.env.ISSUE_NUMBER);

            // Track available labels and allow auto-create of missing labels using GH_PAT
            const available = new Set(
              (process.env.AVAILABLE_LABELS || '')
                .split(',')
                .map(s => s.trim())
                .filter(Boolean)
            );

            // Set labels based on triage result
            if (parsedLabels.labels_to_set && parsedLabels.labels_to_set.length > 0) {
              const proposed = [...new Set(parsedLabels.labels_to_set.map(s => String(s).trim()).filter(Boolean))];

              // Attempt to create any missing labels using the provided token
              for (const label of proposed) {
                if (available.has(label)) continue;
                try {
                  await github.rest.issues.createLabel({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    name: label,
                    color: 'ededed',
                    description: 'Auto-created by Gemini triage'
                  });
                  core.info(`Created missing label: ${label}`);
                  available.add(label);
                } catch (err) {
                  // Ignore if already exists (422), otherwise log error and continue
                  const status = err?.status || err?.response?.status;
                  if (status === 422) {
                    core.info(`Label already exists (race): ${label}`);
                    available.add(label);
                  } else {
                    core.error(`Failed to create label '${label}': ${err}`);
                  }
                }
              }

              const finalLabels = proposed.filter(l => available.has(l));
              if (finalLabels.length === 0) {
                const explanation = parsedLabels.explanation ? ` - ${parsedLabels.explanation}` : '';
                core.info(`No applicable labels for #${issueNumber} after creation attempts. Skipping.${explanation}`);
              } else {
                await github.rest.issues.addLabels({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: issueNumber,
                  labels: finalLabels
                });
                const explanation = parsedLabels.explanation ? ` - ${parsedLabels.explanation}` : '';
                core.info(`Applied labels for #${issueNumber}: ${finalLabels.join(', ')}${explanation}`);
              }
            } else {
              // If no labels to set, leave the issue as is
              const explanation = parsedLabels.explanation ? ` - ${parsedLabels.explanation}` : '';
              core.info(`No labels to set for #${issueNumber}, leaving as is${explanation}`);
            }

      - name: 'Post Issue Analysis Failure Comment'
        if: |-
          ${{ failure() && steps.gemini_issue_analysis.outcome == 'failure' }}
        env:
          ISSUE_NUMBER: '${{ steps.get_issue.outputs.issue_number }}'
          RUN_URL: '${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}'
        uses: 'actions/github-script@60a0d83039c74a4aee543508d2ffcb1c3799cdea'
        with:
          github-token: '${{ steps.generate_token.outputs.token || secrets.GITHUB_TOKEN }}'
          script: |-
            github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: parseInt(process.env.ISSUE_NUMBER),
              body: `There is a problem with the Gemini CLI issue triaging. Please check the [action logs](${process.env.RUN_URL}) for details.`
            })
